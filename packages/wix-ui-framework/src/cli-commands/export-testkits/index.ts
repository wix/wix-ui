import * as path from 'path';
import * as fs from 'fs';

import { fileExists } from '../../file-exists';
import { Process } from '../../typings.d';

interface Options {
  definitions?: string;
  template?: string;
  output?: string;
  _process: Process;
}

const pathResolver = cwd => (...a) => path.resolve(cwd, ...a);

const factoryCreator = 'enzymeTestkitFactoryCreator';
const uniFactoryCreator = 'enzymeUniTestkitFactoryCreator';

const warningBanner = templatePath =>
  `/* eslint-disable */
/*
 * DO NOT EDIT THIS FILE!
 * YOUR CHANGES WILL BE OVERWRITTEN!
 * FILE IS BASED ON ${templatePath}
 * AND GENERATED BY \`wuf export-teskits\`
 */`;

export const exportTestkits: (a: Options) => Promise<void> = async opts => {
  const pathResolve = pathResolver(opts._process.cwd);
  const options = {
    definitions: pathResolve(
      opts.definitions || '.wuf/testkits/definitions.js',
    ),
    template: pathResolve(opts.template || '.wuf/testkits/template.js'),

    output: pathResolve(
      opts.output || `testkit/${path.basename(opts.template)}`,
    ),
  };

  if (!(await fileExists(options.definitions))) {
    throw new Error(
      `ERROR: Definitions file does not exist at "${options.definitions}"`,
    );
  }

  const definitions = require(options.definitions);

  const wrapItemWithFunction = (fn, item) => `${fn}(${item})`;

  // load() is function included during build time. It comes from test/generate-testkit-exports/templates/load.js
  // It is a helper that `require`s given path and extracts export (default or only one found)
  const wrapWithLoad = requirePath =>
    wrapItemWithFunction('load', `require('${requirePath}')`);

  const shouldCreateExport = name =>
    definitions[name]
      ? ['noTestkit', 'manualExport'].every(
          property => !definitions[name][property],
        )
      : true;

  const getExportableTestkits = () =>
    Object.keys(definitions)
      .filter(shouldCreateExport)

      .reduce((testkits, name) => {
        const definition = definitions[name] || {};
        const entryName =
          name[0].toLowerCase() + name.slice(1) + 'TestkitFactory';

        const testkitEntry = wrapItemWithFunction(
          definition.unidriver ? uniFactoryCreator : factoryCreator,
          wrapWithLoad(
            definition.testkitPath ||
              ['..', 'src', name, name + '.driver'].join('/'),
          ),
        );

        testkits[entryName] = testkitEntry;

        return testkits;
      }, {});

  // TODO: the source of `load` should not be here at all, it's a quick workaround
  const loadUtilSource = `const load = module => {
  const MODULE_META_KEYS = ['__esModule'];

  const moduleFields = Object.keys(module).reduce((total, key) => {
    if (!MODULE_META_KEYS.includes(key)) {
      return total.concat(module[key]);
    }
    return total;
  }, []);

  let defaultOrFirstExport;
  if (module.default) {
    defaultOrFirstExport = module.default;
  } else if (moduleFields.length === 1) {
    defaultOrFirstExport = moduleFields[0];
  } else {
    defaultOrFirstExport = module;
  }
  return defaultOrFirstExport;
};`;

  const exportableTestkits = getExportableTestkits();
  const testkitImportsSource = Object.keys(exportableTestkits)
    .map(key => [key, exportableTestkits[key]])
    .map(([name, entry]) => `export const ${name} = ${entry};`)
    .join('\n');

  const templateSource = fs.readFileSync(options.template, 'utf8');
  const source = [
    warningBanner(opts.template),
    templateSource,
    loadUtilSource,
    testkitImportsSource,
  ].join('\n');

  console.log(options.template);

  try {
    fs.writeFileSync(options.output, source);
  } catch (e) {
    throw new Error(`ERROR: Unable to generate testkits: ${e}`);
  }
};
