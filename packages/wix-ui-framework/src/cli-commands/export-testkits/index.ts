import * as path from 'path';
import * as fs from 'fs';
import * as ejs from 'ejs';
import * as get from 'lodash/get';
import * as camelCase from 'lodash/camelCase';

import { fileExists } from '../../file-exists';
import { objectEntries } from '../../object-entries';
import { Options } from './typings';

const pathResolver = cwd => (...a) => path.resolve(cwd, ...a);

// TODO: move the source of `warningBanner` to dedicated file. make sure it gets into output unchanged
export const warningBanner = (templatePath: string) =>
  `/* eslint-disable */
/*
 * DO NOT EDIT THIS FILE!
 * YOUR CHANGES WILL BE OVERWRITTEN!
 * FILE IS BASED ON ${templatePath}
 * AND GENERATED BY \`wuf export-teskits\`
 */`;

// TODO: move the source of `load` to dedicated file. make sure it gets into output unchanged
const loadUtilSource = `const load = module => {
  const MODULE_META_KEYS = ['__esModule'];

  const moduleFields = Object.keys(module).reduce((total, key) => {
    if (!MODULE_META_KEYS.includes(key)) {
      return total.concat(module[key]);
    }
    return total;
  }, []);

  let defaultOrFirstExport;
  if (module.default) {
    defaultOrFirstExport = module.default;
  } else if (moduleFields.length === 1) {
    defaultOrFirstExport = moduleFields[0];
  } else {
    defaultOrFirstExport = module;
  }
  return defaultOrFirstExport;
};`;

const wrapItemWithFunction = (fn, item) => `${fn}(${item})`;

const shouldCreateExport = definitions => name =>
  definitions[name]
    ? ['noTestkit', 'manualExport'].every(
        property => !definitions[name][property],
      )
    : true;

const isEjs = pathname => path.extname(pathname) === '.ejs';

const writeFile = (pathname: string, source: string) => {
  try {
    fs.writeFileSync(pathname, source);
  } catch (e) {
    throw new Error(`Unable to generate testkits: ${e}`);
  }
};

const guards: (a: Options) => Promise<void> = async unsafeOptions => {
  const pathResolve = pathResolver(unsafeOptions._process.cwd);

  if (!unsafeOptions.output) {
    throw new Error('missing --output parameter, it must be defined');
  }

  const options = {
    ...unsafeOptions,
    definitions: pathResolve(
      unsafeOptions.definitions || '.wuf/testkits/definitions.js',
    ),

    components: pathResolve(unsafeOptions.components || '.wuf/components.json'),
    template: pathResolve(
      unsafeOptions.template || '.wuf/testkits/template.js',
    ),
    factoryName: unsafeOptions.factoryName || 'testkitFactoryCreator',
    uniFactoryName: unsafeOptions.uniFactoryName || 'uniTestkitFactoryCreator',
    output: pathResolve(unsafeOptions.output),
    exportSuffix: unsafeOptions.exportSuffix || 'TestkitFactory',
    exportCaseStyle: unsafeOptions.exportCaseStyle || 'camelCase',
  };

  if (!(await fileExists(options.definitions))) {
    throw new Error(
      `Definitions file does not exist at "${options.definitions}"`,
    );
  }

  if (!(await fileExists(options.components))) {
    throw new Error(
      `Components file not found at "${options.components}". It is required for \`wuf export-testkits\`. Create one with \`wuf update\`.`,
    );
  }

  if (!(await fileExists(options.template))) {
    throw new Error(
      `Template file not found at "${options.template}". It is required for \`wuf export-testkits\`.`,
    );
  }

  return makeOutput(options);
};

const defaultSource = ({
  options,
  components,
  definitions,
}: {
  options: Options;
  components: object;
  definitions: object;
}) => {
  const getExportableTestkits = () =>
    Object.keys({
      ...definitions,
      ...components,
    })
      .filter(shouldCreateExport(definitions))

      .reduce((testkits, name) => {
        const definition = definitions[name] || {};
        const entryName =
          options.exportCaseStyle === 'camelCase'
            ? name[0].toLowerCase() + name.slice(1) + options.exportSuffix
            : name + options.exportSuffix;

        const testkitEntry = wrapItemWithFunction(
          definition.unidriver ? options.uniFactoryName : options.factoryName,
          wrapItemWithFunction(
            'load',
            `require('${definition.testkitPath ||
              ['..', 'src', name, name + '.driver'].join('/')}')`,
          ),
        );

        testkits[entryName] = testkitEntry;

        return testkits;
      }, {});

  const exportableTestkits = getExportableTestkits();
  const testkitExportsSource = Object.keys(exportableTestkits)
    .map(key => [key, exportableTestkits[key]])
    .map(([name, entry]) => `export const ${name} = ${entry};`)
    .join('\n');

  return [testkitExportsSource, loadUtilSource].join('\n');
};

const ejsSource = ({ source, definitions, components }) => {
  const utils = {
    toCamel: camelCase,
  };

  const componentsForEjs = objectEntries(components).map(([name, value]) => ({
    name,
    testkitPath: get(definitions, '[name].testkitPath', ''),
    ...value,
  }));

  try {
    return ejs.render(source, {
      utils,
      components: componentsForEjs,
    });
  } catch (e) {
    throw new Error(`Erroneous template file: ${e}`);
  }
};

const makeOutput: (a: Options) => Promise<void> = async options => {
  const components = require(path.resolve(
    options._process.cwd,
    options.components,
  ));
  const definitions = require(options.definitions);
  const templateSource = fs.readFileSync(options.template, 'utf8');

  const testkitsExportsSource = isEjs(options.template)
    ? ejsSource({ source: templateSource, definitions, components })
    : defaultSource({ definitions, options, components });

  const source = [warningBanner(options.template), testkitsExportsSource].join(
    '\n',
  );

  writeFile(options.output, source);
};

export const exportTestkits: (a: Options) => Promise<void> = guards;
