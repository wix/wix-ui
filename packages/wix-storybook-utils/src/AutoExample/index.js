import React, {Component} from 'react';
import PropTypes from 'prop-types';

import styles from './styles.scss';
import NO_VALUE_TYPE from './no-value-type';
import categorizeProps from './categorize-props.js';

import {
  Wrapper,
  Options,
  Option,
  Preview,
  Code,
  Toggle,
  Input,
  List
} from './components';

import SectionCollapse from './components/section-collapse';

const stripQuotes = string => {
  const quoted = string.match(/^['"](.*?)['"]$/);
  return quoted ? quoted[1] : string;
};

const matchFuncProp = typeName =>
  [
    /^func/i,
    /event/,
    /\) => void$/
  ].some(needle => typeName.match(needle));

const ensureRegexp = a =>
  a instanceof RegExp ? a : new RegExp(a);

const propCategoryMatchers = {
  // aria- props
  accessibility: name =>
    name.toLowerCase().startsWith('aria'),

  events: name =>
    name.toLowerCase().startsWith('on')
};

/**
  * Create a playground for some component, which is suitable for storybook. Given raw `source`, component reference
  * and, optionally, `componentProps`,`AutoExample` will render:
  *
  * * list of all available props with toggles or input fields to control them (with `defaultProps` values applied)
  * * live preview of `component`
  * * live code example
  *
  *
  * ### Example:
  *
  * ```js
  * import AutoExample from 'stories/utils/Components/AutoExample';
  * import component from 'wix-style-react/MyComponent';
  * import source from '!raw-loader!wix-style-react/MyComponent/MyComponent'; // raw string, not something like `export {default} from './MyComponent.js';`
  *
  * <AutoExample
  *   source={source}
  *   component={component}
  *   componentProps={{
  *     value: 'some default value',
  *     onClick: () => console.log('some handler')
  *   }}
  * />
  * ```
  */
export default class extends Component {
  static displayName = 'AutoExample';

  static propTypes = {
    /**
     * parsed meta object about component.
     *
     * Generated by `react-autodocs-utils`
     *
     */
    parsedSource: PropTypes.object,

    /** reference to react component */
    component: PropTypes.func.isRequired,

    /**
      * control default props and their state of component in preview.
      *
      * can be either `object` or `function`:
      *
      * * `object` - simple javascript object which reflects `component` properties.
      * * `function` - `(setProps, getProps) => props`
      *      receives `setProps` setter and `getProps` getter. can be used to persist props state and react to event
      *      handlers and must return an object which will be used as new props. For example:
      *
      * ```js
      * <AutoExample
      *   component={ToggleSwitch}
      *   componentProps={(setProps, getProps) => ({
      *     checked: false,
      *     onChange: () => setProps({ checked: !getProps().checked })
      *   })}
      * ```
      */
    componentProps: PropTypes.oneOfType([PropTypes.func, PropTypes.object]),
    exampleProps: PropTypes.object,

    /** when true, display only component preview without interactive props nor code example */
    isInteractive: PropTypes.bool
  }

  static defaultProps = {
    source: '',
    component: () => null,
    componentProps: {},
    parsedSource: {},
    exampleProps: {},
    isInteractive: true
  }

  _initialPropsState = {};

  constructor(props) {
    super(props);

    this.parsedComponent = props.parsedSource;

    this.state = {
      propsState: {
        ...(this.props.component.defaultProps || {}),
        ...(this.prepareComponentProps(this.props.componentProps))
      },
      funcValues: {},
      funcAnimate: {},
      isRtl: false,
      isDarkBackground: false
    };

    this._initialPropsState = this.state.propsState;
    this.categorizedProps = categorizeProps(this.parsedComponent.props, propCategoryMatchers);
  }

  resetState = () =>
    this.setState({propsState: this._initialPropsState});

  componentWillReceiveProps(nextProps) {
    this.setState({
      propsState: {...this.state.propsState, ...this.prepareComponentProps(nextProps.componentProps)}
    });
  }

  prepareComponentProps = props =>
    typeof props === 'function' ?
      props(
        // setState
        componentProps =>
          this.setState({
            propsState: {...this.state.propsState, ...componentProps}
          }),

        // getState
        () => this.state.propsState || {}
      ) :
      props;

  setProp = (key, value) => {
    if (value === NO_VALUE_TYPE) {
      // eslint-disable-next-line no-unused-vars
      const {[key]: deletedKey, ...propsState} = this.state.propsState;
      this.setState({propsState});
    } else {
      this.setState({propsState: {...this.state.propsState, [key]: value}});
    }
  }

  propControllers = [
    {
      types: ['func', /event/, /\) => void$/],

      controller: ({propKey}) => {
        let classNames = styles.example;

        if (this.state.funcAnimate[propKey]) {
          classNames += ` ${styles.active}`;
          setTimeout(() => this.setState({funcAnimate: {...this.state.funcAnimate, [propKey]: false}}), 2000);
        }

        if (this.props.exampleProps[propKey]) {
          return (
            <div className={classNames}>
              {this.state.funcValues[propKey] || 'Interaction preview'}
            </div>
          );
        }
      }
    },

    {
      types: ['bool', 'Boolean'],
      controller: () => <Toggle/>
    },

    {
      types: ['enum'],
      controller: ({type}) =>
        <List values={type.value.map(({value}) => stripQuotes(value))}/>
    },

    {
      types: ['string', 'number', /ReactText/, 'arrayOf', 'union', 'node', 'ReactNode'],
      controller: () => <Input/>
    }
  ]

  getPropControlComponent = (propKey, type) => {
    if (!matchFuncProp(type.name) && this.props.exampleProps[propKey]) {
      return <List values={this.props.exampleProps[propKey]}/>;
    }

    const propControllerCandidate = this.propControllers
      .find(({types}) =>
        types.some(t => ensureRegexp(t).test(type.name))
      );

    return propControllerCandidate && propControllerCandidate.controller ?
      propControllerCandidate.controller({propKey, type}) :
      <Input/>;
  }

  renderPropControllers = ({dataHook, props, allProps}) =>
    Object
      .entries(props)
      .map(([key, prop]) =>
        <Option
          key={key}
          data-hook={dataHook}
          {...{
            label: key,
            value: allProps[key],
            defaultValue: this.props.componentProps[key],
            isRequired: prop.required || false,
            onChange: value => this.setProp(key, value),
            children: this.getPropControlComponent(key, prop.type)
          }}
          />
      )

  getPropsCategories = () => [
    {
      title: 'Component Props',
      props: this.categorizedProps.other,
      isOpen: true
    },

    {
      title: 'Callback Props',
      props: this.categorizedProps.events
    },

    {
      title: 'Accessibility Props',
      props: this.categorizedProps.accessibility
    }
  ]

  render() {
    const functionExampleProps = Object.keys(this.props.exampleProps).filter(
      prop =>
        this.parsedComponent.props[prop] &&
        matchFuncProp(this.parsedComponent.props[prop].type.name)
    );

    const componentProps = {
      ...this.state.propsState,
      ...(
        functionExampleProps
          .reduce((acc, prop) => {
            acc[prop] = (...rest) => {
              if (this.state.propsState[prop]) {
                this.state.propsState[prop](...rest);
              }
              this.setState({
                funcValues: {...this.state.funcValues, [prop]: this.props.exampleProps[prop](...rest)},
                funcAnimate: {...this.state.funcAnimate, [prop]: true}
              });
            };
            return acc;
          }, {})
      )
    };

    const codeProps = {
      ...this.state.propsState,
      ...(
        functionExampleProps
          .reduce((acc, key) => {
            acc[key] = this.props.exampleProps[key];
            return acc;
          }, {})
      )
    };

    if (!this.props.isInteractive) {
      return React.createElement(this.props.component, componentProps);
    }

    return (
      <Wrapper dataHook="auto-example">
        <Options>
          { this
              .getPropsCategories()
              .filter(({props}) => props)
              .map(category =>
                <SectionCollapse
                  key={category.title}
                  title={category.title}
                  isOpen={category.isOpen || false}
                  >
                  { this.renderPropControllers({
                    dataHook: category.name,
                    props: category.props,
                    allProps: componentProps // TODO: ideally this should not be here
                  })
                  }
                </SectionCollapse>
          ) }
        </Options>

        <Preview
          isRtl={this.state.isRtl}
          isDarkBackground={this.state.isDarkBackground}
          onToggleRtl={isRtl => this.setState({isRtl})}
          onToggleBackground={isDarkBackground => this.setState({isDarkBackground})}
          children={React.createElement(this.props.component, componentProps)}
          />

        <Code
          dataHook="metadata-codeblock"
          component={React.createElement(this.props.component, codeProps)}
          displayName={this.parsedComponent.displayName}
          />
      </Wrapper>
    );
  }
}
